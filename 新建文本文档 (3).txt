999 1000
输入+最小 > 1000 取1000
开发  
启用 HMR， devServer，source maps（devtool：source-maps）

{{{{}}}}
webpack性能优化需要自己去配，去尝试
这段时间看看jest
{{{{}}}}

开发
《一》tree shaking 不推荐使用
副作用
1：使用 export default
2：函数存在副作用，如
function unused(a, b) {
    const c = 1;
    console.log(a + b);
}
https://zhuanlan.zhihu.com/p/260724544

export function add(a, b) {
    unused(a,b);
    return a + b
}
一个副作用是：有一些代码，是在 import 时执行了一些行为，这些行为不一定和任何导出相关。例如 polyfill ，Polyfills 通常是在项目中全局引用，而不是在 index.js 中使用导入的方式引用。
Tree Shaking 并不能自动判断哪些脚本是副作用，因此手动指定它们非常重要。
webpack4 的 mode 集成了多个优化项，在 produciton 模式下默认开启了 Tree Shaking
《二》代码分离
把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。
CommonsChunkPlugin 防止重复
《三》懒加载（按需加载）
1 延迟加载在Vue的部件
 components: {
    AsyncCmp: () => import("./AsyncCmp")
  }
2 延迟加载在Vue公司的路由器
new VueRouter({
  routes: [{ path: "/login", component: Login }]
});
3 延迟加载Vuex模块
const store = new Vuex.Store()
import('./store/login').then(loginModule => {
  store.registerModule('login', loginModule)
})
《四》source maps（devtool：false）
《五》source maps（devtool：false）
run -> 35787ms
build -> 46s
3.4M 521KB
https://alexjover.com/blog/lazy-load-in-vue-using-webpack-s-code-splitting/

可以采用html-loader，动态图片不用再requure了


1 在babel-loader上配置
        loader: "babel-loader",
        exclude: /node_modules/,
        options: {
          cacheDirectory: true
        },

确保要转换的文件越少越好。因为您可能匹配/\.m?js$/，所以您可能正在转换node_modules文件夹或其他不需要的源。

要排除node_modules，请参见上面记录exclude的loaders配置中的选项。

您也可以使用该cacheDirectory选项将babel-loader的速度提高2倍。这将把转换缓存到文件系统。

2 ：通过IgnorePlugin设置对moment的整个locale本地化文件夹导入的正则匹配，来防止将所有的本地化文件进行打包。如果你确实需要某国语言，仅手动导入那国的语言包即可。

3： 通过terser-webpack-plugin的parallel和cache配置来并行处理并缓存之前的编译结果。terser-webpack-plugin是之前UglifyPlugin的一个替代品，因为UglifyPlugin已经没有继续维护了，从Webpack4.x起，已经推荐使用terser-webpack-plugin来进行代码压缩、混淆，以及Dead Code Elimination以实现Tree Shaking。对于parallel从整个设置的名称大家就会知道它有什么用，没错，就是并行，而cache也就是缓存该插件的处理结果，在下一次的编译中对于内容未改变的文件可以直接复用上一次编译的结果。

4：HappyPack  多线程（进程）支持